[{"body":"Coat provides three annotations, a type-level annotation @Coat.Config and two method-level annotations @Coat.Param and @Coat.Embedded.\nThe type-level annotation is mandatory. It is the indicator for the annotation processor which interfaces need to be proceessed.\n@Coat.Param and @Coat.Embedded are mutually exclusive.\n@Coat.Config Each interface that should be processed by the annotation processor must be annotated with @Coat.Config.\nThe generated builder class will always be generated in the same package as the annotated interface.\nThe name of the generated builder class is by default the interface name with Builder appended to it.\n@Coat.Config (Javadoc) supports the following attributes:\nclassName The className can be specified to generate a builder class with a different name than when applying the above mentioned naming rules. When className is specified it will be used as the generated builder class name. It will still be generated in the same package as the annotated interface.\n1@Coat.Config(className = \u0026#34;MyConfigBuilder\u0026#34;) 2public interface AppConfig { 3 … 4} casing By default (if not explicitly specified by @Coat.Param#key) Coat expects the key in the config file exactly as the accessor methods name (respecting upper/lower case). To allow for different formats of keys without having to explicitly declare each key, Coat provides a CasingStrategy.\nAS_IS The default. The key is expected in the same case as the accessor methods name. SNAKE_CASE The typical snakeCase of Java method names is converted to snake_case. For example the method name “listenPort” would then be specified as “listen_port” in the config file. KEBAB_CASE Similar to SNAKE_CASE, but instead of underscores an hyphen is used. “listenPort” would be expected as “listen-port”. All the above strategies expect the accessor method names in camelCase (conforming to the Java code formatting conventions). Deviating from that conventions may lead to unexpected results.\n1@Coat.Confg(casing = SNAKE_CASE) 2public interface AppConfig { 3 … 4} stripGetPrefix Coat is agnostic to the naming conventions of the accessor methods. Using the Java Bean Convention of prefixing the methods with “get” leads to strange config keys (that also include the “get” prefix). Therefore Coat strips these prefixes before inferring the key. So the accessor method “getListenPort” would be specified as “listenPort” in the config file, This is necessary when using Java Bean Validation as that specification requires the “get” prefix on all accessors that are about to be validated.\nIf the “get” prefix should not be stripped for some reason, the stripGetPrefix can be set to false to prohibit that behavior.\n1@Coat.Confg(stripGetPrefix = false) 2public interface AppConfig { 3 public boolean getMeABeer(); 4 … 5} converters Coat supports registering custom converters via a static method on the Coat class.\nConverters can also be registered declaratively with the converters attribute. It expects an array of Converter classes to register.\n1@Coat.Confg(converters = { 2 UuidConverter.class, 3 CurrencyConverter.class, 4}) 5public interface AppConfig { 6 public UUID uuid(); 7 public Currency currency(); 8 … 9} listParser Since version 0.0.4 Coat supports Arrays and other collection types. By default it splits the values given in the config file on whitespace. To define a different format to use for Arrays and collections a custom ListParser can be registered.\nSince version 1.0.0 Coat provides such an optional ListParser for splitting config values on commas, ignoring any whitespace around the commas. Of course, other custom ListParsers can be implemented and specified in the same way.\n1@Coat.Confg(listParser = CommaSeparatedListParser.class) 2public interface AppConfig { 3 public InetAddress[] remoteAdresses(); 4 … 5} @Coat.Param Since version 0.0.4 the @Coat.Param annotation on accessor methods is optional.\n@Coat.Param (Javadoc) supports the following attributes:\nkey The parameter key specifies the name of the key as it must be specified in the config file (or the Properties or Map object with which the config class is instantiated).\nIf this key is not specified, it will be automatically inferred from the accessor methods name, respecting the casing and stripGetPrefix parameters of the corresponding @Coat.Config annotation. By default the key will be exactly the same as the accessor methods name.\n1@Coat.Param(key = \u0026#34;listen-port\u0026#34;) 2public int port(); defaultValue A parameter defaultValue can be specified to define a default value that will be used if the config key is missing in the config file. The default value must be specified as a String in the same form it would be specified in the config file. For example:\n1@Coat.Param(defaultValue = \u0026#34;8080\u0026#34;) 2public int port(); The generated config would return the value that was specified in the config file or 8080 if no port was specified.\nconverter Additionally to the corresponding parameter on the @CoatConfig annotation a converter can be specified on the accessor method itself. This will override the default converter specified on the interface.\n1@Coat.Param(converter = MyDateConverter.class) 2public LocalDate startTime(); Use this attribute sparingly and prefer the corresponding attribute on the interface-level annotation @Coat.Config as different formats for the same data types in the same config can be very surprising.\nlistParser Additionally to the corresponding parameter on the @CoatConfig annotation a ListParser can be specified on the accessor method itself. This will override the default ListParser specified on the interface.\n1@Coat.Param(listParser = MyListParser.class) 2public String[] preferredRoles(); Use this attribute sparingly and prefer the corresponding attribute on the interface-level annotation @Coat.Config as different formats for specifying lists in the same config can be very surprising.\n@Coat.Embedded When using nested configurations the annotation @Coat.Embedded must be used instead of @Coat.Param on the corresponding accessor method.\nWhen using @Coat.Embedded the return type of the accessor method must be a @Coat.Config annotated interface.\n@Coat.Embedded (Javadoc) supports the following attributes:\nkey The parameter key specifies the prefix for the config parameters of the embedded config. See @Coat.Param#key for more details about this attribute.\n1@Coat.Embedded(key = \u0026#34;broker\u0026#34;) 2public MqttConfig mqtt(); keySeparator The parameter keySeparator can be specified to define the separator between the prefix and the actual config key of the embedded config. It defaults to a single dot.\n1@Coat.Embedded(keySeparator = \u0026#34;-\u0026#34;) 2public MqttConfig mqtt(); ","link":"https://poiu-de.github.io/coat/user_guide/01_annotations/","title":"Annotations"},{"body":"Generate typesafe config classes Coat is an annotation processor to generate classes for reading configuration values into typesafe objects.\nShort Usage For the following config.properties file 1appName = My shiny app 2listenPort = 5040 3description = Only a test project 4 5 6 7 8 9 10 Define a corresponding interface 1import de.poiu.coat.annotation.Coat; 2 3@Coat.Config 4public interface MyConfig { 5 public String appName(); 6 7 public int listenPort(); 8 9 public Optional\u0026lt;String\u0026gt; description(); 10} Then use the generated class 1final MyConfig config= 2 MyConfigBuilder.from( 3 new File(\u0026#34;/path/to/config.properties\u0026#34;)); 4 5final String appName = config.appName(); 6final int listenPort = config.listenPort(); 7config.description().ifPresent( 8 … 9); 10 Example project See the Example project for a fully executable mini application demonstrating the use of a Coat-generated config class.\nLicense Coat is licensed under the terms of the Apache license 2.0.\n","link":"https://poiu-de.github.io/coat/","title":"Coat — Config of Annotated Types"},{"body":"Kilt provides the following commands:\nexport-xls Exports the translations in Java i18n resource bundle files into an XLS(X) file.\nimport-xls Imports the translations from an XLS(X) file back into the Java i18n resource bundle files.\ncreate-facade Creates the I18n enum facades for type safe access to localized messages.\nreformat Reformat resource bundle files (and actually any .properties files) to a defined format.\nreorder Reorder the entries in resource bundle files (and actually any .properties files) by a certain criterion.\nThose commands are described in more detail in the following sections.\nexport-xls Kilt can generate Excel sheets as either XLS or XLSX and is able to modify both of them. To do this Kilt reads the given Java i18n resource bundles and writes their contents to an existing XLS(X) file or creates a new one. Each row in the generated XLS(X) sheet corresponds to a key in a resource bundle. The actual translations are added as columns to that rows.\nIt's recommended to let Kilt generate the first XLS(X) sheet, since Kilt makes certain assumptions about the structure of that files. Afterwards that file may be prettified to be better readable for the translators. Kilt will only modify the actual translation contents in subsequent generation steps.\nThe generation of an XLS(X) sheet for Java i18n resource bundles works closely together with the reimport of that sheet to provide a common translation workflow. Please see the next section on how to import the translation sheet back into the Java i18n resource bundles.\nimport-xsl An XLS(X) file with updated translations can be reimported back into the Java i18n resource bundles with Kilt.\nKilt will only update values that actually have changed and it will not reorder the resource bundle files (although translated keys that are missing in the resources bundles will be added to the end of the file).\nKilt also allows removing keys from the resource bundles that are missing in the translated XLS(X), but does not do so by default.\ncreate-facade Kilt allows the generation of a Java facade for accessing the available resource bundle entries in a type safe manner. It provides an additional accessor class for easier access to the values of the resource bundle entries.\nThe accessor class can even be used for resource bundles without a generated facade.\nUsage of the Java facade Kilt provides the class I18n for accessing the resource bundles keys of the generated enum facades as well as keys of resource bundles without a generated facade. See the Javadoc for details of using this accessor class.\nA typical usage is:\n1// create an accessor class for the default locale 2final I18n i18n= new I18n(); 3// get the value for the key \u0026#34;MESSAGE_HELLO\u0026#34; from the generated enum 4// facade \u0026#34;Messages\u0026#34; 5final String translatedValue= i18n.get(Messages.MESSAGES_HELLO); 6// get the value for the key \u0026#34;otherKey\u0026#34; from the bundle \u0026#34;otherBundle\u0026#34; 7// for which no facade was generated 8final String valueFromOtherBundle= I18n.get(\u0026#34;otherBundle\u0026#34;, \u0026#34;otherKey\u0026#34;); The accessor class allows marking missing translations instead of throwing a MissingResourceException. This allows to easily spot missing translations without breaking the functionality of the application.\nTranslations are marked only after no fallback translation can be found.\nFor example if you have the following bundles:\nmessages_de_DE.properties messages_de_AT.properties messages_de.properties messages.properties and your current locale is de_AT the translation for a resource entry will be searched in the following files in this order:\nmessages_de_AT.properties messages_de.properties messages.properties Only if the key is not found in any of the above files the resource will be marked as missing. This is no special behaviour of Kilt, but the normal strategy of Java for finding translations.\nMissing translations are marked by default. If you want the normal Java behaviour of throwing a MissingResourceException instead, configure the I18n accessor accordingly.\nTo use the accessor class you need to import the kilt-runtime jar. Either download it from the Download section or add it to your project via the maven coordinates:\n1 \u0026lt;dependencies\u0026gt; 2 \u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;de.poiu.kilt\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;kilt-runtime\u0026lt;/artifactId\u0026gt; 5 \u0026lt;version\u0026gt;1.0.2\u0026lt;/version\u0026gt; 6 \u0026lt;/dependency\u0026gt; 7 \u0026lt;/dependencies\u0026gt; reformat Kilt allows reformatting the entries in resource bundles and other .properties files to a specified format. By default it uses the format \u0026lt;key\u0026gt; = \u0026lt;value\u0026gt;\\n. The format allow specifying possible leading whitespace, the separator char, whitespace around the separator char and the character(s) to use for line breaks (separating the entries).\nBy default, the actual keys and values are not modified at all. By giving the parameter reformatKeyAndWhitespace keys and values will also be reformatted by removing insignificant whitespace, newline and escape characters.\nreorder Kilt allow reordering the entries in resource bundles and other .properties files either alphabetically or by the order given in the specified template file. The handling of comments and empty lines can be specified via parameter attachCommentsTo.\n","link":"https://poiu-de.github.io/kilt/user_guide/01_commands/","title":"Commands"},{"body":"Coat has no runtime dependencies on other libraries.\nThe annotation processor has some dependencies on other libraries (which is why it is recommended to use maven as it resolves those dependencies automatically), but none of them are needed at runtime.\nCoat can be used with Java 11 or higher.\n","link":"https://poiu-de.github.io/coat/quick_start/01_prerequisites/","title":"Prerequisites"},{"body":"Basic prerequisites Java 8 or higher To be integrated into an ant build script When using Java 8 to 10:\nApache ant 1.8.1 or higher When using Java 11+:\nApache ant 1.10.6 or higher 1 To be integrated into a maven build Apache maven 3.0.3 or higher Older version of ant can be used by exporting the environment variable ANT_OPTS=\u0026quot;-Djdk.util.jar.enableMultiRelease=force\u0026quot;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","link":"https://poiu-de.github.io/kilt/quick_start/01_prerequisites/","title":"Prerequisites"},{"body":"Prerequisites Apron has no runtime dependencies on other libraries.\nApron can be used with Java 8 or higher.\nInstallation To use Apron in a maven based project use the following maven coordinates:\n1 \u0026lt;dependency\u0026gt; 2 \u0026lt;groupId\u0026gt;de.poiu.apron\u0026lt;/groupId\u0026gt; 3 \u0026lt;artifactId\u0026gt;apron\u0026lt;/artifactId\u0026gt; 4 \u0026lt;version\u0026gt;2.1.1\u0026lt;/version\u0026gt; 5 \u0026lt;/dependency\u0026gt; Otherwise download the jar-file of Apron from the Github Release page and put it into the classpath of your application.\nUsage Create a de.poiu.apron.PropertyFile object from the content of a .properties file.\nReading a .properties file Apron is fully compatible with the format supported by java.util.Properties, but allows accessing the key value pairs in a more developer-friendly way.\n1// Read the file \u0026#34;application.properties\u0026#34; into a PropertyFile 2final PropertyFile propertyFile= PropertyFile.from( 3 new File(\u0026#34;application.properties\u0026#34;)); 4 5// Read the value of the key \u0026#34;someKey\u0026#34; 6final String someValue= propertyFile.get(\u0026#34;someKey\u0026#34;); Writing changes to a .properties file back Even more important than reading is writing changes back into a .properties file. Other than java.util.Properies Apron does retain\nthe order of all entries\nall empty lines\nall comment lines\nand even the formatting of unchanged entries\n1// Set the value of \u0026#34;someKey\u0026#34; to a new value 2propertyFile.set(\u0026#34;someKey\u0026#34;, \u0026#34;aNewValue\u0026#34;); 3 4// Write the PropertyFile back to file by only updating the modified values 5propertyFile.update(new File(\u0026#34;application.properties\u0026#34;)); ","link":"https://poiu-de.github.io/apron/quick_start/","title":"Quick Start"},{"body":"Starting with Coat is easy. Just write an interface with accessor methods for each field that should be configurable. The return values of the accessor methods can be of any type. Many types are already supported out of the box, but it is possible to use custom types.\nThe source of the configuration data doesn’t matter. While it is mainly intended to be used for the usual Java .properties files, it can be used for any data that is composed of simple String-based key-value-mappings.\nAnnotate the interface with the corresponding Annotations and let the Coat annotation processor generate a concrete implementation of the interface.\nThat implementation can then be used to retrieve correctly typed config values without any additional effort.\nPrerequisites ","link":"https://poiu-de.github.io/coat/quick_start/","title":"Quick Start"},{"body":"This Quick Start Guide describes the first steps in installing and using Kilt. See the User Guide for a description of all the available commands and parameters.\nPrerequisites ","link":"https://poiu-de.github.io/kilt/quick_start/","title":"Quick Start"},{"body":"This guide describes the all features of Apron in detail.\nWhat is Apron ","link":"https://poiu-de.github.io/apron/user_guide/","title":"User Guide"},{"body":"This guide describes all aspects of Coat, how it can be configured and used. It is the full reference manual of Coat.\nAnnotations ","link":"https://poiu-de.github.io/coat/user_guide/","title":"User Guide"},{"body":"Apron is a small library for reading and writing Java .properties files. The main goal of this library is to be compatible with the java.util.Properties class. Not API-wise (the API is quite different), but being able to read every Java .properties file and getting exactly the same key-value pairs as java.util.Properties does.\nHowever Apron maintains the order of the entries in the properties files and also the comments, blank lines and whitespace before keys and around separators.\nThis allows writing .properties files back that do not differ from the original ones.\nSince version 2.0.0 Apron provides the ability to reformat and reorder the content of .properties files according to different constraints.\nSince version 2.1.0 Apron provides a wrapper to be used as a (nearly) drop-in replacement for java.util.Properties.\nApron was mainly written to be used in the Kilt toolset, but was intended from the start to be a general purpose library.\n","link":"https://poiu-de.github.io/apron/user_guide/01_what_is_apron/","title":"What is Apron"},{"body":"Coat consists of two separate jars.\nThe annotation processor to generate the config classes. Only needed at compile time. The runtime package containing the annotations and the default type converters. Needed at runtime. To use Coat in a maven based project use the following maven coordinates:\n1 \u0026lt;!-- Contains the converters and base classes. Needed at runtime. --\u0026gt; 2 \u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;de.poiu.coat\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;coat-runtime\u0026lt;/artifactId\u0026gt; 5 \u0026lt;version\u0026gt;2.0.2\u0026lt;/version\u0026gt; 6 \u0026lt;/dependency\u0026gt; 7 8 \u0026lt;build\u0026gt; 9 \u0026lt;plugins\u0026gt; 10 \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; 11 \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; 12 \u0026lt;configuration\u0026gt; 13 \u0026lt;annotationProcessorPaths\u0026gt; 14 \u0026lt;!-- Specifies the Coat annotation processor. Required from Java 22 onwards. --\u0026gt; 15 \u0026lt;path\u0026gt; 16 \u0026lt;groupId\u0026gt;de.poiu.coat\u0026lt;/groupId\u0026gt; 17 \u0026lt;artifactId\u0026gt;coat-processor\u0026lt;/artifactId\u0026gt; 18 \u0026lt;version\u0026gt;2.0.2\u0026lt;/version\u0026gt; 19 \u0026lt;/path\u0026gt; 20 \u0026lt;/annotationProcessorPaths\u0026gt; 21 \u0026lt;/plugins\u0026gt; 22 \u0026lt;/build\u0026gt; When using Coat in an application that uses Java modules add this to your module-info.java:\n1requires de.poiu.coat.runtime; ","link":"https://poiu-de.github.io/coat/quick_start/02_installation/","title":"Installation"},{"body":"Maven plugin To use the maven plugin of Kilt include the following plugin section in the pom of your project:\n1 \u0026lt;build\u0026gt; 2 \u0026lt;plugins\u0026gt; 3 … 4 \u0026lt;plugin\u0026gt; 5 \u0026lt;groupId\u0026gt;de.poiu.kilt\u0026lt;/groupId\u0026gt; 6 \u0026lt;artifactId\u0026gt;kilt-maven-plugin\u0026lt;/artifactId\u0026gt; 7 \u0026lt;version\u0026gt;1.0.2\u0026lt;/version\u0026gt; 8 \u0026lt;configuration\u0026gt; 9 … 10 \u0026lt;/configuration\u0026gt; 11 \u0026lt;executions\u0026gt; 12 \u0026lt;execution\u0026gt; 13 \u0026lt;id\u0026gt;i18n-facade-generation\u0026lt;/id\u0026gt; 14 \u0026lt;goals\u0026gt; 15 \u0026lt;goal\u0026gt;create-facade\u0026lt;/goal\u0026gt; 16 \u0026lt;/goals\u0026gt; 17 \u0026lt;/execution\u0026gt; 18 \u0026lt;/executions\u0026gt; 19 \u0026lt;/plugin\u0026gt; 20 … 21 \u0026lt;plugins\u0026gt; 22 \u0026lt;build\u0026gt; See the Kilt User Guide for a detailed description of the available goals and configuration parameters.\nAnt task To use the ant task of Kilt download the kilt-ant package from the Download section and either use the integrated build.xml file or use it as a sample to include it in your own ant build script.\nYou will need the accompanied properties file and lib directory as well.\nAs standalone tool To use Kilt as a standalone tool download the kilt-cli package from the Download section and unpack it to a directory of your choice.\n","link":"https://poiu-de.github.io/kilt/quick_start/02_installation/","title":"Installation"},{"body":"Coat allows embedding config objects in other config objects.\nIt is helpful in the case when parts of a configuration are reused in multiple other configurations without having to duplicate all the accessor methods of the embedded config class.\nExample As an example see the following MqttConfig that is embedded in the main AppConfig.\n1@Coat.Config 2public interface MqttConfig { 3 4 @Coat.Param(key = \u0026#34;client_id\u0026#34;) 5 public Optional\u0026lt;String\u0026gt; clientId(); 6 7 @Coat.Param(key = \u0026#34;broker_address\u0026#34;) 8 public InetAddress brokerAddress(); 9 10 @Coat.Param(key = \u0026#34;port\u0026#34;, defaultValue = \u0026#34;1883\u0026#34;) 11 public int port(); 1@Coat.Config 2public interface AppConfig { 3 4 @Coat.Param(key = \u0026#34;name\u0026#34;) 5 public String name(); 6 7 @Coat.Embedded(key = \u0026#34;mqtt\u0026#34;) 8 public MqttConfig mqtt(); A config file for that configuration would look like this:\n1name = … 2mqtt.client_id = … 3mqtt.broker_address = … 4mqtt.port = … The config keys of the embedded config get a common prefix that is specified on the @Coat.Embedded annotation of its accessor method. By default that prefix is separated from the actual config key via a single dot.\n","link":"https://poiu-de.github.io/coat/user_guide/02_nesting_configurations/","title":"Nesting Configurations"},{"body":"Kilt supports the following parameters that can be set in the configuration files for the standalone tool and the ant task and in the plugin configuration of the maven plugin.\nAll parameters can additionally be given as command line parameters to override the configuration for the standalone tool and the maven plugin. The parameters of the ant task can not be overridden.\nThe following list describes the available parameters and to which commands they apply.\nParameter Description export-xls import-xls create-facade reformat reorder verbose Whether to generate more verbose output. ✔ ✔ ✔ ✔ ✔ propertiesRootDirectory The directory below which the i18n resource bundle files reside. ✔ ✔ ✔ ✔ ✔ i18nIncludes The Java i18n resource bundles to include in the processing. ✔ ✔ ✔ ✔ ✔ i18nExcludes The Java i18n resource bundles to exclude from the processing. ✔ ✔ ✔ ✔ ✔ propertyFileEncoding The encoding of the Java i18n resource bundle files. ✔ ✔ ✔ ✔ ✔ xlsFile The XLS(X) file to export to / import from. ✔ ✔ missingKeyAction What to do if the target file contains key-value pairs that do not exist in the input file. ✔ facadeGenerationDirectory The directory to write the generated file(s) to. ✔ generatedPackage The package name into which to generate the Java enum facade classes. ✔ copyFacadeAccessorClasses Whether to copy the facade accessor classes into the generated output. ✔ facadeAccessorClassName The class name to use when copying the facade accessor classes. ✔ format The format to use for formatting the entries in the resource bundles. ✔ reformatKeyAndValue Whether to reformat the keys and values themselves by removing insignificant whitespace and line breaks. ✔ byKey Reorder the entries alphabetically by the name of their keys. ✔ byTemplate Reorder the entries in the same order as the key-value pairs in this template file. ✔ attachCommentsTo How to handle comment lines and empty lines on reordering. ✔ verbose Print more verbose output.\nSpecifying this options lets Kilt print more informational messages about what it is doing.\nWhen using the maven plugin this also requires the option -X to let maven actually print the additional output.\npropertiesRootDirectory The location of the source i18n resource bundle files.\nAll resource bundles that are handled by Kilt must reside in this directory (or any subdirectory of arbitrary depth).\nIn a maven application this will usually be src/main/resources.\ni18nIncludes The Java i18n resource bundles to include in the processing.\nFile globbing is supported with the following semantics:\n? matches a single character * matches zero or more characters ** matches zero or more directories For example if you have the following resource bundles:\nmessages_de.properties messages_en.properties buttons_de.properties buttons_en.properties internal/exceptions_de.properties internal/exceptions_en.properties internal/messages.properties internal/messages_en.properties these are the results for the following patterns\u0026gt;\nPattern Resulting files **/*.properties All properties files messages*.properties messages_de.properties messages_en.properties **/messages_en.properties messages_en.properties internal/messages_en.properties i18nExcludes The files to exclude from the list of resources bundles given in i18nIncludes.\nFile globbing is supported with the same semantics as for the i18nIncludes.\npropertyFileEncoding The encoding of the Java i18n resource bundle files.\nPrior to Java 9 the default encoding in Java was ISO-8859-1, since Java 9 it is UTF-8.\nxlsFile The XLS(X) file to export to / import from.\nOn export, if the file doesn’t exist already it will be created. If it already exists it will be updated (retaining formatting and unrelated content). It is advisable to let Kilt generate the first version of the file before making manual changes, since Kilt expects a certain structure of the file.\nmissingKeyAction How to handle key-value-pairs that exist in the .properties file, but not in the XLS(S) file to import.\nThe following values are valid:\nValue Description NOTHING Leave exising key-value-pairs as they are DELETE Delete the missing key-value-pairs COMMENT Comment out the missing key-value-pairs facadeGenerationDirectory The directory to write the generated Java enum facade classes to.\nThe default value when using the maven plugin is ${project.build.directory}/generated-sources/kilt otherwise it is generated-sources.\ngeneratedPackage The package name into which to generate the Java enum facade classes.\ncopyFacadeAccessorClasses Whether to copy the facade accessor class and the base interface I18nBundleKey to the generation target dir.\nThis is only useful if it is necessary to avoid a runtime dependency on kilt-runtime, which provides these classes.\nfacadeAccessorClassName The name of the facade accessor class when copying the facade accessor classes.\nThis is only meaningful in combination with copyFacadeAccessorClasses.\nformat The format to use when reformatting entries of resource bundles.\nThe given format string must conform to the following specification:\nIt may contain some leading whitespace before the key. It must contain the string \u0026lt;key\u0026gt; to indicate the position of the properties key (case doesn’t matter) It must contain a separator char (either a colon or an equals sign) which may be surrounded by some whitespace characters. It must contain the string \u0026lt;value\u0026gt; to indicate the position of the properties value (case doesn’t matter) It must contain the line ending char(s) (either \\n or \\r or \\r\\n) The allowed whitespace characters are\nthe space character the tab character the linefeed character. Therefore a typical format string is\n\u0026lt;key\u0026gt; = \u0026lt;value\u0026gt;\\n for\nno leading whitespace an equals sign as separator surrounded by a single whitespace character on each side \\n as the line ending char. But it may as well be\n\\t \\f\u0026lt;key\u0026gt;\\t: \u0026lt;value\u0026gt;\\r\\n for a rather strange format with\na tab, a whitespace and a linefeed char as leading whitespace\na colon as separator char preceded by a tab and followed a single space character\n\\r\\n as the line ending chars\nIf the format string is omitted the default value of \u0026lt;key\u0026gt; = \u0026lt;value\u0026gt;\\n will be used.\nreformatKeyAndValue Whether to reformat the keys and values of reformatted entries by removing insignificant whitespace and linebreaks.\nbyKey Reorder the entries of resource bundles alphabetically by the name of their keys.\nThis option may not be given at the same time as byTemplate.\nbyTemplate Reorder the entries of resource bundles in the same order as the key-value pairs in this template file.\nThis option may not be given at the same time as byKey.\nattachCommentsTo How to handle comment lines and empty lines when reordering the entries of resource bundles.\nPossible values are:\nValue Desription NEXT_PROPERTY Comments and empty lines are attached to the key-value pair after them. PREV_PROPERTY Comments and empty lines are attached to the key-value pair before them. ORIG_LINE Comments and empty lines remain at their current position. ","link":"https://poiu-de.github.io/kilt/user_guide/02_parameters/","title":"Parameters"},{"body":"Introduction Kilt is a set of small tools to ease the handling of Java i18n resource bundles.\nIt can help by\nConverting i18n resource bundles to and from XLS(X) sheets for easier translation by a small translation team.\nProviding a facade to access the entries in a i18n resource bundle statically in a type safe way.\nReformatting and reordering entries in resource bundles to maintain a constant style and order.\nKilt is available as:\na standalone application\nan ant task to be integrated with an ant-based application\na maven plugin to be integrated with a maven-based application\nTranslation workflow support Kilt supports the translation workflow inside a company by providing the translation resources (Java i18n resource bundles) as a more translator-friendly XLS(X) sheet. The translation team can then do their translations directly inside the XLS(X) sheet. The translated sheet can then be imported back into the actual resource bundles used by the application.\nBy utilizing the Apron library the import of the XLS(X) file into the Java i18n resource bundles is minimally invasive. It does not change the order of the entries in the resource bundles and all comments and empty lines are preserved.\nThe same is true for the export to XLS(X). No reordering is done to entries that already exist in the sheet and all cell sizes, colors etc. remain as they are.\nType-safe access to i18n resources The usual approach of accessing translated resources in Java uses strings and is therefore quite error-prone. Typos are common and the software developer needs to know the exact name of the resource bundle key.\nKilt eases the usage of translated resoures by allowing to generate enum facades for resource bundles to allow type-safe access to these resources. This approach not only shows problems with localization at compile time, but it is also easy for the developers to find the necessary resources by utilizing the code completion of modern IDEs.\nThe generated enum facades even contain the actual translated values in the javadoc of the facades enum values and therefore make it even easier to spot if the selected resource contains the correct value for the intented purpose.\nFor example instead of\n1final ResourceBundle bundle= ResourceBundle.getBundle(\u0026#34;messages\u0026#34;); 2final String msg= bundle.getString(\u0026#34;msg.confirm_deletion\u0026#34;); you would write\n1final I18n i18n= new I18n(); 2final String msg= i18n.get(Khm.MSG_CONFIRM_DELETION); Reformatting and Reordering The formatting and the order of the entries in the resource bundles may deviate over time when different developers are working on it. While this is more of a cosmetic problem, it still reduces the readability and comparability of the resource bundles.\nKilt uses the Apron library to provide commands for reformatting and reordering the entries in the resource bundles to reintroduce consistency.\n","link":"https://poiu-de.github.io/kilt/user_guide/","title":"User Guide"},{"body":"Some examples for usage scenarios of Apron are:\nUsing .properties files as config files for an application that may be manually edited by a user as well as modified by the application itself (e.g. via a configuration dialog). The manual modifications (like the order of entries, as well as comments, empty lines and even the formatting of entries) will remain.\nExporting and importing Java i18n resource bundles for translation (like Kilt does).\nReordering multiple .properties files to contain their entries in the same order.\nReformatting .properties files to conform to a specific format.\n","link":"https://poiu-de.github.io/apron/user_guide/02_what_can_apron_be_used_for/","title":"What can Apron be used for"},{"body":"The main important class in Apron is de.poiu.apron.PropertyFile. It provides methods to create a new instance by reading a .properties file from File or InputStream as well as methods for populating an instance programmatically.\nThe main difference to the usual java.util.Properties is that this class does not implement the java.util.Map interface and provides access to the content of the PropertyFile in two different ways:\nas key-value pairs\nas Entries\nThe key-value pairs are the actual interesting content of the .properties files and are the same as when read via java.util.Properties. However, since PropertyFile is able to retain all comments, blank lines and even the formatting of the file it stores all this information in objects of type Entry. There are two implementations of Entry:\nBasicEntry\nA non-key-value pair like a comment or an empty line\nPropertyEntry\nAn actual key-value pair\nThe Entry objects store their content in escaped form. That means all whitespaces, linebreaks, escape characters, etc. are contained in exactly the same form as in the written .properties file.\nThe key-value pairs instead contain the content in unescaped form (as you would expect from java.util.Properties).\nTo minimize confusion the escaped values are stored as CharSequence whereas the unescaped values are stored as String.\nA PropertyFile instance also allows writing its content back to disk. It provides 3 methods (each in two variants) for doing so:\noverwrite\nWrites the contents of the PropertyFile to a new file or overwrite an existing file.\nupdate\nUpdate an existing .properties file with the values in the written PropertyFile.\nsave\nUse either the above mentioned overwrite method if the given file does not exist or the update method if the file already exists.\nThe most interesting method is the update method, since this differentiates PropertyFile from java.util.Properties. It actually only updates the values of the key-value pairs without touching any other formatting. Blank lines, comments, whitespaces and even escaping and special formatting of the keys are not altered at all. Also the order of the key-value pairs remains the same.\nThe behaviour when writing a PropertyFile can be altered by providing it an optional ApronOptions object.\nThis is an example for a typical usage of PropertyFile as a replacement for java.util.Properties:\n1// Read the file \u0026#34;application.properties\u0026#34; into a PropertyFile 2final PropertyFile propertyFile= PropertyFile.from( 3 new File(\u0026#34;application.properties\u0026#34;)); 4 5// Read the value of the key \u0026#34;someKey\u0026#34; 6final String someValue= propertyFile.get(\u0026#34;someKey\u0026#34;); 7 8// Set the value of \u0026#34;someKey\u0026#34; to a new value 9propertyFile.set(\u0026#34;someKey\u0026#34;, \u0026#34;aNewValue\u0026#34;); 10 11// Write the PropertyFile back to file by only updating the modified values 12propertyFile.update(new File(\u0026#34;application.properties\u0026#34;)); This is an example for a more advanced usage of PropertyFile that allows accessing comment lines and explicitly formatted (escaped) entries:\n1// Read all Entries (that means BasicEntries as well as PropertyEntries) 2final List\u0026lt;Entry\u0026gt; entries= propertyFile.getAllEntries(); 3 4// Add a comment line to this PropertyFile 5propertyFile.appendEntry(new BasicEntry(\u0026#34;# A new key-value pair follows\u0026#34;)); 6 7// Add a new key-value pair to this PropertyFile 8// Be aware that by using appendEntry() it could be possible to insert 9// duplicate keys into this PropertyFile. The behaviour is then undefined. 10// It is the responsibility of the user of PropertyFile to avoid this. 11// PropertyEntries contain their content in _escaped_ form. Therefore the 12// Backslashes and newline character are not really part of the key and value 13propertyFile.appendEntry(new PropertyEntry(\u0026#34;a new \\\\\\nkey\u0026#34;, \u0026#34;a new \\\\\\nvalue\u0026#34;)); 14 15// key-value pairs are _unescaped_. Therefore the following method call 16// will return the string \u0026#34;a new value\u0026#34; 17final String myNewValue= propertyFile.get(\u0026#34;a new key\u0026#34;); 18 19// Specify an ApronOptions object that writes with ISO-8859-1 encoding 20// instead of the default UTF-8. 21final ApronOptions apronOptions= ApronOptions.create() 22 .with(java.nio.charset.StandardCharsets.ISO_8859_1); 23 24// Write the PropertyFile back to file by only updating the modified values 25propertyFile.update(new File(\u0026#34;application.properties\u0026#34;), apronOptions); See the Javadoc API for more details.\n","link":"https://poiu-de.github.io/apron/user_guide/03_basic_usage/","title":"Basic Usage"},{"body":"Create config interface Write an interface with accessor methods for each config entry your application supports. The accessor methods can return the concrete types you want your config entry to be. There is a number of types that are supported by default, but custom types can be registered to support additional types.\nConfig values that are optional, must be of type java.util.Optional or the more specialized variants OptionalInt, OptionalLong or OptionalDouble. All other config values are considered mandatory. Missing mandatory values will fail validation on construction time and therefore raise an exception (with details about the validation failures).\nThe interface must be annotated with the @Coat.Config annotation for the annotation processor to recognize it.\nEach accessor may be annotated with the @Coat.Param annotation to tell the processor the corresponding key in the config file (if it should be different than what Coat would infer otherwise) or a default value in case the key is missing in the config file.\nBoth annotations have some possible attributes that can be set which are described in Annotations.\nFor example:\n1package com.example; 2 3import de.poiu.coat.annotation.Coat; 4 5@Coat.Config 6public interface AppConfig { 7 public String appName(); 8 9 public InetAddress remoteIP(); 10 11 @Coat.Param(default = \u0026#34;5044\u0026#34;) 12 public int remotePort(); 13 14 @Coat.Param(key = \u0026#34;long_description\u0026#34;) 15 public Optional\u0026lt;String\u0026gt; description(); 16} Generate the builder for the config class When compiling the project the annotation processor will produce a builder to build a concrete implementation of the interface in the same package and (by default) the same name with Builder appended to it. Therefore the above example interface would produce an com.example.AppConfigBuilder class.\nUse the generated builder The generated builder can be instantiated with a number of different config sources. Since version 1.0.0 Coat also allows instantiation from multiple sources at the same time.\nConfig Sources The main source of config entries for Coat are java.util.Map\u0026lt;String, String\u0026gt;s. For common config sources some shortcut methods exist that provide direct support, but in all other cases everything that can be represented as a map of String keys to String values can be used as a config source.\njava.util.Map\u0026lt;String, String\u0026gt; A map with key-value mappings can directly be given to Coat to instantiate a Config class with these entries.\njava.io.File The traditional approach of specifying config entries in Java is via Property-Files. Coat explicitly supports this use case by allowing a File object as config source which in then read via Javas loading mechanism for Property-Files.\njava.util.Properties Instead of specifying a file, a Properties object can be directly fed into Coat as config source. This allows, for example, the usage of Java System Properties as config source by reading them via System#getProperties().\nWhile java.util.Properties can theoretically contain non-String keys or values, Coat does not allow these and will drop such entries (generating a warning message).\nEnvironment variables Special support is provided for reading config entries from environment variables. This is a common approach for applications running in containers.\nUnfortunately the allowed character set for environment variable keys is much stricter than the character set in Coat config (and therefore Java Properties) files. For that reason a relaxed mapping is applied to match environment variables to Coat config keys.\nAll dots and hyphens are treated as underscores. All uppercase characters in Coat config keys are preceded by an underscore (to convert camelCase to UPPER_CASE). The comparison between the environment variables and the Coat config keys is done case insensitively. For example the environment variable SERVER_MQTT_HOST will match the config key server.mqttHost.\nInstantiation via static factory methods Static factory methods are provided for reading config values from a single config source:\nfrom(java.util.Map) from(java.util.Properties) from(java.io.File) fromEnvVars() Example:\n1final MyConfig config= MyConfigBuilder.from(System.getProperties()); Instantiation with multiple config sources The generated builder allows for using multiple config sources by using different add methods.\nThe order in which the config sources are read is defined by the order in which they are added to the builder. Later config sources overwrite values with the same keys of earlier config sources.\nFor example for reading the basic config from a config file, but allow overriding some entries via environment variables:\n1final MyConfig config= MyConfigBuilder.create() 2 .add(new File(\u0026#34;myConfig.properties\u0026#34;)) 3 .addEnvVars() 4 .build(); Validation of config objets Since version 2.0.0 config objects are always validated at construction time. Therefore all the static factory methods as well as the #build() method of the generated Builder throw a ConfigValidationException in case this validation fails. See Validation for a more detailled description of the validation process.\n1public class MyApp { 2 public static void main(String[] args) { 3 try { 4 final AppConfigBuilder config= AppConfigBuilder.from( 5 new File(\u0026#34;/path/to/config.properties\u0026#34;)); 6 7 System.out.println(\u0026#34;Starting \u0026#34; + config.appName()); 8 config.description().ifPresent(System.out::println); 9 10 final Socket s= new Socket(config.remoteIP(), config.remotePort()); 11 12 … 13 } catch (final ConfigValidationException ex) { 14 System.err.println(\u0026#34;Error in config file:\\n\u0026#34; 15 + ex.getValidationResult().toString()); 16 System.exit(1); 17 } 18 } 19} ","link":"https://poiu-de.github.io/coat/quick_start/03_usage/","title":"Usage"},{"body":"Kilt can be used in three different ways.\nAs a standalone application\nAs an ant task\nAs a maven plugin\nStandalone tool To use Kilt as a standalone tool, download and unpack the kilt-cli package from the Download page.\nIt contains a shell script for Linux, a batch file for Windows and a kilt.properties file for the configuration.\nTo execute the tool run\n./kilt.sh \u0026lt;command\u0026gt; on Linux or\nkilt.bat \u0026lt;command\u0026gt; on Windows.\nYou may override the configuration in the kilt.properties file by specifying some properties as parameters to the command. For example to create an XLS(X) sheet only for the english language run\n./kilt.sh export-xls --include=**/*_en*.properties See Commands for a list of the available commands and Parameters for a detailed description of the available configuration parameters.\nTo show the usage help of the tool call it with the parameter -h or --help:\n./kilt.sh --help To show the usage help of a specific command use the command help followed by the required command:\n./kilt.sh help export-xls or specify the -h or --help flag after that command:\n./kilt.sh export-xls --help Ant task To use Kilt as an ant task, download and unpack the kilt-ant package from the Download page.\nIt contains a build.xml file and a kilt.properties file to be used standalone (but still requires ant to be run) or as a sample to be integrated into the build script of another application.\nTo execute a command run\nant \u0026lt;command\u0026gt; See Commands for a list of the available commands and Parameters for a detailed description of the available configuration parameters.\nMaven plugin You can use the maven plugin to import and export an XLS(X) sheet on the fly, but since translations are usually an iterative process and will be done more than once, it is much more common to configure the kilt-maven-plugin for the project containing the Java i18n resource bundle files.\nHowever, usually it is not necessary to generate an XLS(X) sheet with every build, therefore the corresponding maven goal is not bound to any maven lifecycle phase by default.\nTo integrate the kilt-maven-plugin into your application include the following plugin section in the pom of your project:\n1 \u0026lt;build\u0026gt; 2 \u0026lt;plugins\u0026gt; 3 … 4 \u0026lt;plugin\u0026gt; 5 \u0026lt;groupId\u0026gt;de.poiu.kilt\u0026lt;/groupId\u0026gt; 6 \u0026lt;artifactId\u0026gt;kilt-maven-plugin\u0026lt;/artifactId\u0026gt; 7 \u0026lt;version\u0026gt;1.0.2\u0026lt;/version\u0026gt; 8 \u0026lt;configuration\u0026gt; 9 … 10 \u0026lt;/configuration\u0026gt; 11 \u0026lt;/plugin\u0026gt; 12 … 13 \u0026lt;plugins\u0026gt; 14 \u0026lt;build\u0026gt; See Parameters for a detailed description of the available configuration parameters.\nTo execute a goal run\nmvn kilt:\u0026lt;command\u0026gt; You may override the configuration of the pom by specifying some properties as parameters to the command. For example to create an XLS(X) sheet only for the english language run\nmvn kilt:export-xls -Di18nIncludes=\u0026quot;**/*_en*.properties\u0026quot; ","link":"https://poiu-de.github.io/kilt/quick_start/03_usage/","title":"Usage"},{"body":"Coat validation On creating a config class from the generated builder the configuration will always be validated in order to fail early in case the given configuration is missing some values or existing values cannot be converted into the specified type.\nIf the configuration is invalid, it will throw a ConfigValidationException. This exception has a method getValidationResult() that returns a value of type ValidationResult that contains more information about the missing or wrong config values.\nTo issue an error message, the toString() method of the ValidationResult can be used. For example\n1try { 2 MyConfig config= MyConfigBuilder.from(props); 3} catch (final ConfigValidationException ex) { 4 System.err.println(\u0026#34;Error in config file:\\n\u0026#34; 5 + ex.getValidationResult().toString()); 6 System.exit(1); 7} Java Bean Validation While coat doesn’t provide explicit support for Java Bean Validation they can be used together.\nJava Bean Validation allows for more specific constraints on the values in a config object, e.g. minimum and maximum values of an integer. Just add the appropriate annotations to the accessor methods and validate them with a jakarta.validation.Validator.\nBe aware that Java Bean Validation requires the usage of “get” prefixes on the accessor methods. Coat explicitly supports this use case by stripping that prefix when inferring the config key by default.\nSee the example project for a usage example of Java Bean Validation with Coat.\n","link":"https://poiu-de.github.io/coat/user_guide/03_validation/","title":"Validation"},{"body":"Builtin types The following types are supported by Coat out of the box and can directly be used as return types of the accessor methods in the annotated interface.\njava.lang.Integer java.lang.Long java.lang.Float java.lang.Double java.lang.String java.time.Duration java.time.LocalDate java.time.LocalDateTime java.time.LocalTime java.io.File java.nio.file.Path java.nio.charset.Charset java.net.InetAddress java.net.URI For each supported type a converter class exists in the package de.poiu.coat.convert.converters. Refer to the corresponding Java API docs for details about the expected format of the input string.\nThe following primitive types are also supported by default. But those are different in that they are directly supported without any Converter.\nint\nInteger values can be specified in decimal (no prefix), hexadecimal (prefixed by 0x), octal (prefixed by 0) or binary (prefixed by 0b) form.\nlong\nLong values can be specified in decimal (no prefix), hexadecimal (prefixed by 0x), octal (prefixed by 0) or binary (prefixed by 0b) form.\ndouble\nDouble values can be specified in decimal (no prefix) or hexadecimal (prefixed by 0x) form.\nFor decimal values an optional exponent can be appended, in which case it must be separated with e or E, like 1.0e5. For hexadecimal values the exponent is mandatory and must be separated with p or P, like 0xaaP5. In either case the exponent can optionally be signed (e. g. 1.0e+5).\nboolean\nThe strings “true\u0026quot; and “yes” (regardless of their case) are considered as Boolean.TRUE, all other Strings (including null) are considered to be Boolean.FALSE.\nBe aware that numeric types (int, long, double) do not allow the specification of a type suffix (l for long, d for double, etc.) as would be valid in a Java literal numeric value.\nHowever, underscores for separating parts of a number (like 1_000_000) are supported.\nRegistering custom types Coat allows registering custom types to be used in the annotated interface.\nA static method Coat#registerGlobalConverter() is provided to register a converter for a specific type. To do this, the interface de.poiu.coat.convert.Converter must be implemented for that specific type and registered with the above mentioned method.\nThe Coat#registerGlobalConverter() method must be called before creating a config object using such a type.\nThe Coat#registerGlobalConverter() method can additionally be used for overriding the builtin converter for a type. For example if durations should be specified in some other format than the default converter supports, write a custom converter for the java.time.Duration type and register it via\n1Coat.registerGlobalConverter(new MyDurationConverter()); As support for primitive types is directly implemented and not via Converter it is currently not possible to override the parsing of primitive types with a custom Converter. If different parsing of such types is necessary the corresponding object type must be used and a Converter for that type be written (e. g. a Converter\u0026lt;Integer\u0026gt;).\nAdditionally to the above mentioned method of registering custom converters at runtime, they can also be specified declaratively on the corresponding annotations. See the description of these annotation parameters on the type and on the field level annotations for more information.\nCurrently unsupported types At the moment the primitive types short, float, char and byte are not supported. Therefore the next “bigger” types must be used (e. g. int instead of short) or the corresponding class (e. g. Short instead of short).\nCollection types Since version 0.0.4 Coat supports Arrays and collections as return values of accessor methods.\nArrays java.util.List java.util.Set Arrays are only supported for object types, not primitive types. Be aware that Arrays are by nature mutable. For that reason Lists should be preferred instead.\nBy default the values of collection types are expected to be separated by whitespace. Whitespace inside a single value can be used by prefixing each such whitespace character with a backslash. For example the value one\\ two three would then be split into a collection with the two values one two and three.\nAdditionally, since version 1.0.0 a CommaSeparatedListParser is provided for splitting around commas (ignoring any whitespace around the commas). It will not be used by default and must be explicitly declared as a custom ListParser.\nDefault values are supported for arrays and collections as well.\n1@Coat.Config 2public AppConfig { 3 @Coat.Param(defaultValue = \u0026#34;UTF-8 US-ASCII\u0026#34;) 4 public Charset[] allowedCharsets(); 5} Registering custom ListParser Coat allows for different formats than the default whitespace separated values by registering a custom ListParser. Each generated config class provides a static method registerListParser() to register a custom parser for such values. Additionally such a ListParser can be declared on the @Coat.Config annotation as well as on the @Coat.Param annotation.\nA custom ListParser must implement the de.poiu.coat.convert.ListParser interface.\nOptional values Config entries that are optional must be encapsulated in java.util.Optional or the more specialized variants OptionalInt, OptionalLong or OptionalDouble need to be used. All other config values are considered mandatory. Missing mandatory values will throw an exception at validation time.\nEmbedded types may be optional, too. They are considered present if at least one config entry with the corresponding key and separator was found. In that case all mandatory values of the embedded config must be present.\nOptional collections are not supported out of the box. The generation will succeed, but no converter will be found at runtime. Most of the time an optional collection does not make much sense and an empty collection should be returned in case no value is specified. Optional collections may be supported by providing a custom converter for that specific collection, for example:\n1public class IntListConverter implements Converter\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; { 2 private final IntegerConverter ic= new IntegerConverter(); 3 4 @Override 5 public List\u0026lt;Integer\u0026gt; convert(final String stringValue) throws TypeConversionException { 6 final String[] splitString= stringValue.split(\u0026#34;\\\\s+\u0026#34;); 7 final List\u0026lt;Integer\u0026gt; result= new ArrayList(splitString.length); 8 for (final String s : splitString) { 9 result.add(ic.convert(s)); 10 } 11 12 return result; 13 } 14} ","link":"https://poiu-de.github.io/coat/user_guide/04_supported_types/","title":"Supported Types"},{"body":"Example config file generation The annotation processor generates an example config file (conforming to the specification of Java .properties files) for each annotated interface. That example contains an entry for each accessor method.\nIf an accessor method is optional, the entry in the example will be commented out.\nIf an accessor method provides a default value for a property, the entry in the example will be commented out and the default value is assigned.\nOtherwise (mandatory property, no default value) the entry in the example will not be commented out and does not have an assigned value.\nAny javadoc comments on the accessor methods will be copied as a comment above the corresponding entry in the example file.\nThe generated example file will have the same name as the annotated interface with .properties appended and will be placed in a directory examples. It will be generated in the same path as the generated classes. The example files can then be accessed via their resource path. For an annotated interface ExampleConfig (regardless of the package it is defined in) the corresponding example file can then be accessed in the classpath as /examples/ExampleConfig.properties.\nThis is most useful when packaging an application to include a commented default config file that already contains all valid properties, for example with the maven-assembly-plugin.\nGeneration at runtime The generated builder class provides a static method writeExampleConfig(java.io.Writer) that allows generating the very same example config at runtime. This is helpful in cases when the example config should only be generated on a users demand.\nCaveats The block tags of the javdoc comments on the accessor methods are stripped off before copying them into the example config.\nHowever at the moment the remaining javadoc is copied as is. That means all HTML markup and all javadoc tags will be copied, too.\n","link":"https://poiu-de.github.io/coat/user_guide/05_example_config/","title":"Example config"},{"body":"Since version 2.0.0 Apron provides a de.poiu.apron.reformatting.Reformatter class that allows reformatting and reordering the content of .properties files.\nThe specific behaviour when reformatting and reordering can be specified via a de.poiu.apron.reformatting.ReformatOptions object.\nFor convenience the de.poiu.apron.PropertyFile class provides some methods to reformat or reorder the entries in that PropertyFile.\nReformatting When reformatting a format string can be given to specify how to format leading whitespace, separators and line endings. The default format string is \u0026lt;key\u0026gt; = \u0026lt;value\u0026gt;\\n for\nno leading whitespace\nan equals sign surrounded by a single whitespace on each side as separator\na \\n (line feed) character as new line character\nBy default the keys and values of the reformatted files are not modified. That means any special formatting (like insignificant whitespace, newlines and escape characters) remain after reformatting.\nThis can be changed via the reformatKeyAndValue option in which case these will be modified as well.\nThis is an example for reformatting a PropertyFile:\n1// Create the ReformatOptions to: 2// - read and write with UTF-8 (which is the default anyway), 3// - reformat via a custom format string and 4// - also reformat the keys and values. 5final ReformatOptions reformatOptions= ReformatOptions.create() 6 .with(UTF_8) 7 .withFormat(\u0026#34;\u0026lt;key\u0026gt;: \u0026lt;value\u0026gt;\\r\\n\u0026#34;) 8 .withReformatKeyAndValue(true) 9 ; 10 11// Create a Reformatter with the specified ReformatOptions 12final Reformatter reformatter= new Reformatter(reformatOptions); 13 14// Reformat a single .properties file according to the specified ReformatOptions 15reformatter.reformat(new File(\u0026#34;myproperties.properties\u0026#34;)); Reordering Reordering the content of .properties files can be done either by alphabetically sorting the keys of the key-value pairs or by referring to a template file in which case the keys are ordered in the same order as in the template file.\nApron allows specifying how to handle non-property lines (comments and empty lines) when reordering. It is possible to move them along with the key-value pair that follows them or the key-value pair that precedes them or be just left at the same position as they are.\nThis is an example for reordering a PropertyFile:\n1// Create the ReformatOptions to use that does not reorder empty lines and comments 2final ReformatOptions reorderOptions= ReformatOptions.create() 3 .with(AttachCommentsTo.ORIG_LINE) 4 ; 5 6// Create a Reformatter with the specified ReformatOptions 7final Reformatter reformatter= new Reformatter(reorderOptions); 8 9// Reorder a single .properties file alphabetically 10// according to the specified ReformatOptions 11reformatter.reorderByKey(new File(\u0026#34;myproperties.properties\u0026#34;)); 12 13// Reorder a single .properties file according to the order in another .properties file 14// This time we want to reorder comments and empty lines along with the 15// key-value pair that follows them. This is possible by specifying a ReformatOptions 16// object when calling the corresponding reorder method. 17reformatter.reorderByTemplate( 18 new File(\u0026#34;template.properties\u0026#34;), 19 new File(\u0026#34;someOther.properties\u0026#34;), 20 reorderOptions.with(AttachCommentsTo.NEXT_PROPERTY) 21); ","link":"https://poiu-de.github.io/apron/user_guide/05_reformatting_and_reordering/","title":"Reformatting and Reordering"},{"body":"The javadoc for the public classes is published online.\nSee coat-runtime for a description of the annotations and the default converters.\n","link":"https://poiu-de.github.io/coat/user_guide/06_api_reference/","title":"API reference"},{"body":"Since version 2.1.0 Apron provides a de.poiu.apron.java.util.Properties class as a wrapper to be used as a drop-in replacement where a java.util.Properties object is required.\nThis wrapper derives from java.util.Properties, but uses an Apron PropertyFile as the actual implementation.\nExample To use it create it either via\n1de.poiu.apron.PropertyFile propertyFile= … 2de.poiu.apron.java.util.Properties properties= 3 new de.poiu.apron.java.util.Properties(propertyFile); or via\n1de.poiu.apron.PropertyFile propertyFile= … 2de.poiu.apron.java.util.Properties properties= propertyFile.asProperties(); All access via the properties object will then access to the propertyFile object. Both objects can be used interchangebly to access the actual contents.\nDifferences to java.util.Properties The wrapper tries to fulfil the java.util.Properties API as good as possible. However there are a few differences:\njava.util.Properties is derived from Hashtable and therefore non-String keys and values can be stored in it (although that is highly discouraged). As Aprons PropertyFile is not derived from Hashtable it doesn’t share this flaw. Therefore trying to use any other objects than Strings as keys or values will fail.\nAprons PropertyFile only supports key-value-based .properties files. As java.util.Properties also provides methods to read and write to XML files and those formats are not supported by Apron, the corresponding methods will always throw an UnsupportedOperationException.\njava.util.Properties being derived from Hashtable is thread-safe. However Aprons PropertyFile is not thread-safe and therefore this wrapper is also not thread-safe.\n","link":"https://poiu-de.github.io/apron/user_guide/06_jup_wrapper/","title":"java.util.Properties wrapper"},{"body":"There are a few cases this library issues some logging statements (when closing a writer didn’t succeed and if an invalid unicode sequence was found that will be left as is). Those few logging statements don’t justify a dependency on a logging framework. Therefore we just use java.util.logging for that purpose.\nWhen using Apron in an application that uses another logging framework please use those logging frameworks ability to bridge java.util.logging to their actual implementation.\nFor log4j2 this can be done by including the log4j2-jul and log4j2-api jar (and some implemention, e.g. log4j2-core) and setting the system property java.util.logging.manager to org.apache.logging.log4j.jul.LogManager. See https://logging.apache.org/log4j/2.x/log4j-jul.html for more information.\nFor slf4j this can be done by including the jul-to-slf4j jar (and some implementation, e.g. logback) and programmatically calling\n1SLF4JBridgeHandler.removeHandlersForRootLogger(); 2SLF4JBridgeHandler.install(); or setting the handler in the logging.properties:\n1handlers = org.slf4j.bridge.SLF4JBridgeHandler See https://www.slf4j.org/legacy.html#jul-to-slf4j for more information.\n","link":"https://poiu-de.github.io/apron/user_guide/07_logging/","title":"Logging"},{"body":"In some cases Coat issues logging statements. To not introduce a third-party dependency just for that case, the java.lang.System.Logger is used for that purpose. By default this uses java.util.logging as the actual logging implementation, but can be reconfigured to use a different implementation.\nFor example to log via log4j2 the maven artifact org.apache.logging.log4j:log4j-jpl must be specified as a dependency:\n1 \u0026lt;dependency\u0026gt; 2 \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; 3 \u0026lt;artifactId\u0026gt;log4j-jpl\u0026lt;/artifactId\u0026gt; 4 \u0026lt;version\u0026gt;${log4j-version}\u0026lt;/version\u0026gt; 5 \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; 6 \u0026lt;/dependency\u0026gt; For slf4j the maven artifact slf4j-jdk-platform-logging must be specified as a dependency:\n1 \u0026lt;dependency\u0026gt; 2 \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; 3 \u0026lt;artifactId\u0026gt;slf4j-jdk-platform-logging\u0026lt;/artifactId\u0026gt; 4 \u0026lt;version\u0026gt;${slf4j-version}\u0026lt;/version\u0026gt; 5 \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; 6 \u0026lt;/dependency\u0026gt; The following events emit log messages\nWhen reading the configuration from a java.util.Properties object, but the Properties contain some non-string entry, a WARNING message is emitted that this entry will be ignored. When reading the configuration from environment variables an INFO message is emitted for each entry that was mapped from an environment variable to a config key. ","link":"https://poiu-de.github.io/coat/user_guide/07_logging/","title":"Logging"},{"body":"While performance never was a design goal of Coat it turned out that Coat actually has excellent performance. It is so fast compared to other config libraries that this section of the user manual was written to cover that detail.\nOn github a tool exists that already compares different config libraries. This tool also provides a a benchmark for Coat. It shows that Coat 1.0.0 already was faster than all other config libraries for Strings, but less so for ints. The reason is that Coat supports more sophisticated parsing rules for numeric values (with separating underscores) that have a performance penalty on parsing time.\nBut due to the immutable nature of Coat generated config classes this parsing does not need to be done after creating the config object, but can be integrated into the creation. Therefore Coat 2.0.0 addresses that issue and does all parsing on creation time of the object.\nComparison A full comparison using above mentioned tool, but providing a more Coat-focused view shows that all accessors are now several orders of magnitude faster than all the other tested config libraries and even more than 4 times faster than reading simple Strings out of System Properties.\nDue to that a Coat-generated config can be used directly even in the most performance-critical code paths without having to worry about storing config variables locally to avoid bottlenecks when accessing a config variable very often.\nRuntime performance The benchmark is extended to illustrate that different types don't impact the performance a significant way.\nThe only benchmark standing out a bit (due to “only“ 70% of the performance of the other benchmarks) is the one involving redirection. It accesses an InetAddress object from am EmbeddedConfig object from the main config object:\n1config.mqtt().hostName() For comparison, both, accessing the EmbeddedConfig as a whole object and accessing the InetAddress directly from the EmbeddedConfig show the full 100% performance. In real life a service needing access to the value of an embedded config will likely already have a reference to only that object instead of the main config object (that is what embedded configs were designed for) and don‘t need even that redirection.\nCreation performance It is expected that the high performance at runtime (accessing the config values) comes with a much worse performance on creation time (reading and parsing the config values). Looking at the benchmark result the creation performance is still better than expected.\nA mini-config with a single int and a single string (like with the benchmarks for all the other config libraries) puts Coat on the third position, still faster than most alternatives. When adding more config entries, the time for constructing the object and especially parsing the config values increases. The example is a config with a list of 4 LocalDate objects and an embedded config object with an InetAddress.\nBear in mind that this creation time was only benchmarked out of curiosity and usually has no relevance in real life. Creation is done only once per config and profiling the example application shows that the effort to prepare the Java Bean Validation takes more than 20 times longer than constructing the config object.\n","link":"https://poiu-de.github.io/coat/user_guide/08_performance/","title":"Performance"},{"body":"First public release.\n","link":"https://poiu-de.github.io/coat/release_notes/0.0.1/","title":"0.0.1"},{"body":" CoatConfig#validate() now checks whether config values can be converted to their corresponding type.\nThe generated config classes now provide a method writeExampleConfig to write an example config (in a syntax valid for Java .properties files) to a provided Writer.\nThe annotation processor now generates an example .properties file for each annotated interface.\nThe annotation processor now adds an equals() and hashCode() method to each generated class.\nA new annotation @Coat.Embedded is provided to allow embedding @Code.Config annotated interfaces in other @Coat.Config annotated interfaces. This allows for better reusablity of config classes and improved readability.\n","link":"https://poiu-de.github.io/coat/release_notes/0.0.2/","title":"0.0.2"},{"body":" Use java.lang.System.Logger instead of java.util.logging.Logger in CoatConfig.\nCorrectly handle inherited accessor methods from multiple interfaces.\nAccessor methods that are totally equal will only be generated once. Accessor methods that have the same name, but are otherwise not totally equal (e.g. differing return type or differing default value) prevent the generation.\nCheck that the same key is not used for different accessor methods.\nDon’t try to generate a config from an interface which has methods that return void or accept parameters (as they can’t be used as accessors).\nAdd support for Boolean objects (as opposed to primitive booleans).\nCorrectly handle numeric values in hexadecimal, binary and octal notation.\n","link":"https://poiu-de.github.io/coat/release_notes/0.0.3/","title":"0.0.3"},{"body":" The @Coat.Param annotation is now optional. All methods in an interface with the @Coat.Config annotation are now considered. The “key” will be inferred from the accessor method name if missing.\nTo influence the style of the inferred keys a CasingStrategy can be specified.\nArrays and Collection types are now supported.\nConverters are provided for “boxed” primitives now.\nConverters can be specified declaratively on the annotation level now (on @Coat.Config and @Coat.Param level). The same is true for ListParsers for the new collection types.\nAllow underscores in numbers for better readablity.\nIgnore non-Coat annotations instead of producing broken code.\nAllow stripping a “get” prefix from the accessor name when inferring the “key”.\n","link":"https://poiu-de.github.io/coat/release_notes/0.0.4/","title":"0.0.4"},{"body":" Initial release of kilt after fork from i18n-binder\nTotally new facade generation that generates enum facades\nRenamed commands and parameters\nUpdate XLS(X) files instead of overwriting them\nEmpty cells in XLS(X) and default resource bundles (without country code) are now supported\nAdded kilt-cli as commandline application without dependency on ant\nAdded kilt-runtime as runtime module for the generated facades (and even without a generated facade)\n","link":"https://poiu-de.github.io/kilt/release_notes/0.2.0/","title":"0.2.0"},{"body":" Mark default language column in XLS(X) with \u0026lt;default\u0026gt;\nGet rid of dependency on utils-apl-derived and use PropertyFile from apron library instead\nImplemented functionality to comment out or delete missing keys when importing XLS(X) back to .properties files\nAdd an additional info sheet to the written XLS(X) with some infos about the generation\n","link":"https://poiu-de.github.io/kilt/release_notes/0.3.0/","title":"0.3.0"},{"body":" Upgrade Apron library to 2.0.1 to benefit from bugfixes:\nEscape newlines to literal newlines\nUpdating a PropertyFile updates values even if the unescaped form doesn’t differ\nAn escaped literal newline is replaced with a newline\n","link":"https://poiu-de.github.io/kilt/release_notes/0.3.1/","title":"0.3.1"},{"body":" Initial release of Apron ","link":"https://poiu-de.github.io/apron/release_notes/1.0.0/","title":"1.0.0"},{"body":" A new ListParser is provided for specifying comma-separated lists (ignoring whitespace around the commas). This CommaSeparatedListParser will not be used by default, but must explicitly be set on a @Coat.Config or @Coat.Param annotation or via CoatConfig#registerListParser(ListParser).\nBREAKING CHANGE: The generated immutable config files will not have a public constructor anymore. Instead a builder will be generated to create config objects as well as static from(…) factory methods.\nA config class can now be initialized via multiple config sources at once. For this the new builder (see above) needs to be used. The order in which the sources are applied is defined explicitly when creating the config instance.\nConfig values can now be read from environment variables. For that purpose a fromEnvVars() method is provided as a static factory method as well as a method of the generated builder. Since environment variables only allow a much more restricted character set than config files, a relaxed parsing of config keys is applied in that case.\nBREAKING CHANGE: The writeExampleConfig(BufferedWriter) will not be generated anymore. If a BufferedWriter is required, this should be applied explicitly by the caller. However, as the example config is written all at once the benefit of using a BufferedWriter is questionable.\nCoatConfigs without any accessor methods are supported now. While a totally empty CoatConfig is rather useless, it is helpful if a CoatConfig only comprises multiple embedded configs.\n","link":"https://poiu-de.github.io/coat/release_notes/1.0.0/","title":"1.0.0"},{"body":"base Provide new commands to reformat and reorder resource bundles\nWrite a few more log messages\nProvide example application to show usage of Kilt\nxls-import / xls-export Avoid error on values without key\nAvoid errors when reading XLS(X) files with null values\nDo not create empty files on xls-import\nMaintain order of entries on xls-export\nxls-import now respects i18nInclude and i18nExclude properties\ncreate-facade I18n facade now provides #contains() method\nI18n facade now provides #getOrDefault() method\nGenerated enum facades don’t have a @Generated annotation anymore\nPackage of generated enum facades is now de.poiu.kilt.facade\nSort translations in javadoc of generated enum facade\ncli Show valid missingKeyActions in CLI help\nRefined messages of CLI application\nmaven-plugin Combine xlsFileName and xlsOutputDirectory parameters to xlsFile in maven-plugin ","link":"https://poiu-de.github.io/kilt/release_notes/1.0.0/","title":"1.0.0"},{"body":" Faster parsing of numeric values.\nCorrectly remove underscores from hex numbers if the numbers contain uppercase letters or numeric digits.\n","link":"https://poiu-de.github.io/coat/release_notes/1.0.1/","title":"1.0.1"},{"body":"base Fix bundle basename for bundles not in subfolder ","link":"https://poiu-de.github.io/kilt/release_notes/1.0.1/","title":"1.0.1"},{"body":" Update all 3rd-party dependencies (no functional changes) ","link":"https://poiu-de.github.io/kilt/release_notes/1.0.2/","title":"1.0.2"},{"body":" Added functionality to reformat and reorder the entries in a PropertyFile\nRenamed de.poiu.apron.Options to de.poiu.apron.ApronOptions\n","link":"https://poiu-de.github.io/apron/release_notes/2.0.0/","title":"2.0.0"},{"body":" Custom ListParsers on @Coat.Config annotation are now correctly applied to that class only. Previously they influenced all other classes, too.\nA new default converter for URIs is provided by Coat.\nThe runtime performance of calling the accessor methods of the config object has been massively improved by executing all validation and type conversion at creation time of the config object.\nBREAKING CHANGE: The publicly visible generated class in now not the concrete implementation of the config interface anymore, but instead the builder to create it. The actual implementation is now hidden. To create an instance of the builder an new static Builder#create() method is provided.\nBREAKING CHANGE: The name of the generated builder class can be specified as was the case with the generated implementation before. But the special handling of a leading underscore has been removed.\nBREAKING CHANGE: Validation is now always done on creating the config object via builder. Therefore no separate validate method will be available anymore. That also means that the ConfigValidationException will be thrown on calling the build() method of the builder or one of the static factory methods.\nBREAKING CHANGE: Custom global converters and list parsers are not registered on the config implementation anymore, but instead on the Coat class that also provides the annotations.\nBREAKING CHANGE: The MessageDigestConverter that was provided by default before has been dropped. As it is a stateful object it is not thread-safe and therefore doesn’t fit the Coat concept. Of course it can still be provided by the application itself if the missing thread-safety is of no concern. It just isn’t provided by default anymore.\nThe example app now uses a List instead of an array as arrays are always mutable and should be avoided in Coat config classes.\nMigration guide While the list above is mainly comprised of breaking changes, they are all very straight forward and migration from an older version of Coat is rather easy. The static factory methods of the previously generated config class are provided by the builder now.\nFor example a using the static factory methods before was:\n1final ImmutableMyConfig config= ImmutableMyConfig.from(new File(\u0026#34;/path/to/config.properties\u0026#34;)); 2 3CoatConfig.registerConverter(new MyCustomConverter()); 4 5try { 6 config.validate(); 7} catch (ConfigValidationException ex) { 8 … 9} and now becomes:\n1Coat.registerGlobalConverter(new MyCustomConverter()); 2 3try { 4 final MyConfig config= MyConfigBuilder.from(new File(\u0026#34;/path/to/config.properties\u0026#34;)); 5} catch (ConfigValidationException ex) { 6 … 7} Using the builder before was:\n1final ImmutableMyConfig config= ImmutableMyConfig.builder().add(props).addEnvVars().build(); 2 3try { 4 config.validate(); 5} catch (ConfigValidationException ex) { 6 … 7} and now becomes:\n1try { 2 final MyConfig config= MyConfigBuilder.create().add(props).addEnvVars().build(); 3} catch (ConfigValidationException ex) { 4 … 5} ","link":"https://poiu-de.github.io/coat/release_notes/2.0.0/","title":"2.0.0"},{"body":" Escape newlines to literal newlines\nWhen checking for value changes compare unescaped values\nEscape backslashes when escaping\n","link":"https://poiu-de.github.io/apron/release_notes/2.0.1/","title":"2.0.1"},{"body":" Support Java modules. The module name is de.poiu.coat.runtime.\nFix parsing of boolean value \u0026quot;1\u0026quot;.\nCorrectly close reader after usage.\n","link":"https://poiu-de.github.io/coat/release_notes/2.0.1/","title":"2.0.1"},{"body":" Fix generation of config builders with embedded configs from a different package. ","link":"https://poiu-de.github.io/coat/release_notes/2.0.2/","title":"2.0.2"},{"body":" Provide JPMS module-info to be used in JPMS modularized applications The module-info will only be used by Java 9+. All other classes are still compatible with Java 8.\nProvide java.util.Properties wrapper around PropertyFile\nMake appendEntry methods public\nReplace setValue method with set. setValue still exists, but is deprecated from now on.\n","link":"https://poiu-de.github.io/apron/release_notes/2.1.0/","title":"2.1.0"},{"body":"A better API for accessing Java .properties files Apron is a library for providing a developer-friendly way for reading and writing Java .properties files. In particular it supports writing changes to a .properties file in the least intrusive way possible.\nShort Usage Provide a .properties file 1## Apron example ## 2 3# The appName can be changed in-app 4appName = My shiny app 5 6# The default port is 5040. 7# Change it if necessary 8#listenPort = 5040 9 10# This description is only visible in 11# the \u0026#34;About\u0026#34; dialog. 12description = Only a \\ 13 test project 14 15 16 Read it and modify some entries 1import de.poiu.apron.PropertyFile; 2 3 4final File file= new File(\u0026#34;application.properties\u0026#34;); 5final PropertyFile propertyFile= PropertyFile.from(file); 6 7// Read the value of the key \u0026#34;appName\u0026#34; 8final String appName= propertyFile.get(\u0026#34;appName\u0026#34;); 9 10// Change the value of \u0026#34;appName\u0026#34; to a new value 11propertyFile.set(\u0026#34;appName\u0026#34;, \u0026#34;My brilliant app\u0026#34;); 12 13// Write the PropertyFile back to file 14// by only updating the modified values 15propertyFile.update(file); 16} Read the result 1## Apron example ## 2 3# The appName can be changed in-app 4appName = My brilliant app 5 6# The default port is 5040. 7# Change it if necessary 8#listenPort = 5040 9 10# This description is only visible in 11# the \u0026#34;About\u0026#34; dialog. 12description = Only a \\ 13 test project 14 15 16 License Apron is licensed under the terms of the Apache license 2.0.\n","link":"https://poiu-de.github.io/apron/","title":"Apron — Advanced Properties"},{"body":"Easier handling of Java I18n resource bundles Kilt is a set of small tools to ease the handling of Java i18n resource bundles.\nIt can help by\nConverting i18n resource bundles to and from XLS(X) sheets for easier translation by a small translation team. Providing a facade to access the entries in a i18n resource bundle statically in a type safe way. Reformat and reorder entries in resource bundles to maintain a constant style and order. Short Usage Create facade for accessing translation keys For resource bundle i18n/msg.properties 1ok = OK 2cancel = Cancel 3yes = Yes 4no = No 5 6 7 Generate the facade 1 ./kilt.sh create-facade \\ 2 -i msg.properties 3 4 5 6 7 Then use the generated facade 1final I18n i18n= new I18n(); 2 3String s; 4s = i18n.get(Msg.CANCEL); 5s = i18n.get(Msg.OK); 6Locale.setDefault(Locale.GERMAN); 7s = i18n.get(Msg.CANCEL); Export XLS(X) sheet for translation For all your resource bundles 1i18n/msg.properties 2i18n/msg_de.properties 3i18n/msg_nl.properties Export them to a single XLS sheet 1 ./kilt.sh export-xls \\ 2 -i \u0026#34;msg*.properties\u0026#34; 3 Then sent it to translators 1… 2 3 Import XLS(X) sheet with translations (Re)import XLS file with translations 1 ./kilt.sh import-xls \\ 2 -i \u0026#34;msg*.properties\u0026#34; 3 4 5 This updates the resource bundles 1i18n/msg.properties 2i18n/msg_de.properties 3i18n/msg_nl.properties 4i18n/msg_fr.properties 5 Then use the new translations 1final I18n i18n= new I18n(); 2 3String s: 4Locale.setDefault(Locale.FRENCH) 5s = i18n.get(Msg.CANCEL) See the User Guide for a more thorough explanation of the possibilities.\nLicense Kilt is licensed under the terms of the Apache license 2.0.\n","link":"https://poiu-de.github.io/kilt/","title":"Kilt — Kilt I18n L10n T9n"},{"body":"poiu – Libraries for Java Apron Read and write Java .properties files in a more sane manner Kilt Easier handling of Java i18n resource bundles Coat Type safe config objects for Java ","link":"https://poiu-de.github.io/","title":"poiu"},{"body":"","link":"https://poiu-de.github.io/apron/release_notes/","title":"Release Notes"},{"body":"","link":"https://poiu-de.github.io/coat/release_notes/","title":"Release Notes"},{"body":"","link":"https://poiu-de.github.io/kilt/release_notes/","title":"Release Notes"},{"body":" There are no immediate plans for the implementation of further features.\nOf course, contributions are welcome to support more features in the future. In any case, before starting to implement a feature, discuss it on the Github issue page to avoid wasted effort due to duplicate work or differing ideas of how a feature should be implemented.\n","link":"https://poiu-de.github.io/coat/roadmap/","title":"Roadmap"}]